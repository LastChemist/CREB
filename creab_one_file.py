"""
Author : LastChemist (https://github.com/LastChemist)
Date : 2024-07-13 (YY:MM:DD)

Note : this is a one file code for easier operations.

header info generated by : AI Assistant
Overview

This code is an equation utility library that provides a set of tools for processing chemical equations. It can parse chemical formulas, count the occurrences of each element, and perform various operations on the formula.

Key Features

Parenthesis Matching: The library can match parentheses in a given string to ensure that they are balanced.
Element Mapping: It can map elements in a chemical formula to their corresponding counts.
Element Counting: The library can count the occurrences of each element in a chemical formula.
Equation Parsing: It can parse a chemical equation into reactants and products.
Use Cases

This library can be used in various applications that involve chemical equations, such as:

Chemical Reaction Simulation: This library can be used to simulate chemical reactions by parsing and processing chemical equations.
Chemical Formula Analysis: It can be used to analyze chemical formulas and extract information about the elements and their counts.
Molecular Biology: This library can be used in molecular biology applications to analyze and process DNA or protein sequences.
Advantages

Efficient Parsing: The library provides efficient parsing algorithms for chemical equations, making it suitable for large-scale applications.
Accurate Element Counting: The library accurately counts the occurrences of each element in a chemical formula, which is essential for many scientific applications.
Flexible: The library is designed to be flexible and can be easily extended to support new features and operations.
Example Use Cases

Here are some example use cases that demonstrate the functionality of this library:

Parsing a simple chemical equation: H2O + CO2 â†’ H2CO3
Counting the occurrences of each element: H(2)O + C(1)O(2) â†’ H(2)C(1)O(3)
Mapping elements to their counts: H(2)O + C(1)O(2) â†’ {H: 2, C: 1, O: 3}
"""

import assets
from copy import deepcopy
from sympy import symbols
import os
import pickle
import re


parameter_assigned_chemical_formulas_dict: dict = {}
last_parameter: str = ""


class EquationUtil:
    def set_parameter_assigned_chemical_formulas_dict(self, value):
        global parameter_assigned_chemical_formulas_dict
        parameter_assigned_chemical_formulas_dict = value

    def set_last_parameter(self, value):
        global last_parameter
        last_parameter = value

    class Parenthesis:
        """
        A class used to match parentheses in a given string.

        ...

        Attributes
        ----------
        input_string : str
            a string which may contain parentheses

        Methods
        -------
        get_parenthesis_indices():
            Returns a dictionary with opening parenthesis indices as keys and closing parenthesis indices as values.
        check_balanced_parentheses():
            Checks if the parentheses in the string are balanced.
        execute_matching():
            Executes the matching process and returns the indices of matching pairs if parentheses are balanced.
        """

        def __init__(self, input_string: str):
            """
            Constructs all the necessary attributes for the ParenthesisMatcher object.

            Parameters
            ----------
                input_string : str
                    a string which may contain parentheses
            """
            self.input_string = input_string

        def get_parenthesis_indices(self):
            """
            Returns a dictionary with opening parenthesis indices as keys and closing parenthesis indices as values.

            Returns
            -------
            dict
                a dictionary with opening parenthesis indices as keys and closing parenthesis indices as values
            """
            parenthesis_stack = []
            parenthesis_pairs = {}
            for position, character in enumerate(self.input_string):
                if character == "(":
                    parenthesis_stack.append(position)
                elif character == ")" and parenthesis_stack:
                    opening_position = parenthesis_stack.pop()
                    parenthesis_pairs[opening_position] = position
            return parenthesis_pairs

        def check_balanced_parentheses(self):
            """
            Checks if the parentheses in the string are balanced.

            Returns
            -------
            bool
                True if parentheses are balanced, False otherwise
            """
            parenthesis_stack = []
            for character in self.input_string:
                if character == "(":
                    parenthesis_stack.append(character)
                elif character == ")":
                    if not parenthesis_stack or parenthesis_stack[-1] != "(":
                        return False
                    parenthesis_stack.pop()
            return not parenthesis_stack

        def execute_matching(self):
            """
            Executes the matching process and returns the indices of matching pairs if parentheses are balanced.

            Returns
            -------
            dict or str
                a dictionary with opening parenthesis indices as keys and closing parenthesis indices as values if parentheses are balanced, otherwise a string indicating unmatched pairs found
            """
            if self.check_balanced_parentheses():
                return self.get_parenthesis_indices()
            else:
                return "Unmatched pairs found."

    # --------------

    class ElementMapper:
        def __init__(self, chemical_formula: str) -> None:
            self.chemical_formula: str = chemical_formula
            self.search_elements: list = [assets.element_list]

        def search(self):
            """
            Once upon a time, in the land of programming, a developer was working on a project to analyze chemical formulas. They had a list of all the elements in the periodic table and a chemical formula as a string, like 'Na2(SO4)3'. Their task was to write a Python method that would count the occurrences of each element in the formula.

            The developer started by creating a class called `ElementMapper` with a method named `search`. This method would go through each element in the periodic table and search for it in the chemical formula. It seemed like a straightforward task, but the developer soon ran into a problem.

            The issue was that some element symbols are substrings of other element symbols. For example, 'N' is a substring of 'Na'. So when the method searched for 'N' in 'Na2(SO4)3', it found 'N' in 'Na', which was not the desired behavior.

            To solve this problem, the developer sorted the elements in descending order of their length before searching. This way, 'Na' would be searched before 'N', and the method would correctly identify 'Na' in the formula. However, this solution did not handle elements that are part of a group inside parentheses, like 'S' and 'O' in 'SO4'.

            The developer then modified the `search` method to use a stack to keep track of the groups and their multipliers. When a '(' was encountered, the code would look ahead to find the corresponding ')' and the number following it, which was the multiplier for the group. This multiplier was then used when counting the elements inside the group.

            After making these modifications, the `search` method was finally able to correctly identify and count the elements in the chemical formula 'Na2(SO4)3'. The developer was relieved and grateful for the help they received along the way. They learned a lot about problem-solving and debugging in Python, and they were now ready to tackle the next challenge in their project.

            And so, the developer continued their journey in the land of programming, armed with new knowledge and experience. They knew that no matter how tough the problems might get, they could always find a solution if they kept trying and learning. And they lived happily ever after, coding away into the sunset. ðŸ˜Š
            """

            # This regex pattern will match element symbols and their counts
            pattern = re.compile(r"([A-Z][a-z]*)(\d*)")

            # Initialize an empty dictionary to store the elements and their counts
            found_elements = {}

            # Iterate over all matches in the chemical formula
            for match in pattern.finditer(self.chemical_formula):
                # Get the element symbol and its count
                element = match.group(1)
                count = int(match.group(2)) if match.group(2) else 1

                # If the element is already in the dictionary, add the count to its existing count
                if element in found_elements:
                    found_elements[element][0] += count
                # Otherwise, add the element to the dictionary with its count and the length of its symbol
                else:
                    found_elements[element] = [count, len(element)]

            return found_elements

    # --------------

    class ElementCounter:
        # Applies on a single chemical formula
        def __init__(self, chemical_formula: str) -> None:
            self.chemical_formula: str = chemical_formula
            self.chemical_formula_copy: str = deepcopy(chemical_formula)
            self.number_list: list[str] = assets.number_list
            self.present_elements: list = list(
                EquationUtil().ElementMapper(chemical_formula).search()
            )
            self.parenthesis_map: list = list(
                EquationUtil().Parenthesis(chemical_formula).execute_matching().items()
            )

            self.global_element_map: dict = {}
            self.element_index_in_chemical_formula_map: dict = {}
            self.container_dict: dict = {}
            self.element_index_map: dict = {}

        def elementsIterationMapper(self) -> dict:
            """return format :
            {
                element_1: [
                    element_length,
                    iteration_index_1,
                    iteration_index_2,
                      ...,
                    iteration_index_n,
                ],
              ...,
               element_n: [
                    element_length,
                    iteration_index_1,
                    iteration_index_2,
                      ...,
                    iteration_index_n,
                ]
            }
            e.g. input H2O > output : {"H":[1,1],"O":[1,1]}
            """
            element_iteration_count: dict = {}
            temp_list: list = []
            for element in self.present_elements:
                element_length: int = len(element)
                temp_list.append(element_length)
                while True:
                    iteration_index: int = self.chemical_formula.find(element)
                    if iteration_index != -1:
                        self.chemical_formula = (
                            self.chemical_formula[:iteration_index]
                            + "*" * element_length
                            + self.chemical_formula[iteration_index + element_length :]
                        )
                        temp_list.append(iteration_index)
                        continue
                    else:
                        break
                element_iteration_count[element] = temp_list
                temp_list = []
            return element_iteration_count

        # ---------

        def mapElements(self) -> None:
            element_map: dict = self.elementsIterationMapper()
            container_dict: dict = {}
            reversed_container_dict: dict = {}
            for _ in range(len(self.parenthesis_map)):
                container_dict[_] = self.parenthesis_map[_]
            for _ in range(len(self.parenthesis_map)):
                reversed_container_dict[self.parenthesis_map[_]] = _
            original_element_list: list = []
            parameter: str = ""
            for _ in range(len(self.parenthesis_map)):
                opening_parenthesis_index, closing_parenthesis_index = (
                    self.parenthesis_map[_]
                )
                for element_index_list in list(element_map.values()):
                    original_element_list = element_index_list
                    element_index_list = element_index_list[1:]
                    for element_index in element_index_list:
                        if element_index > closing_parenthesis_index:
                            break
                        else:
                            parameter = self.chemical_formula_copy[
                                element_index : element_index + original_element_list[0]
                            ]
                        if element_index in range(
                            opening_parenthesis_index, closing_parenthesis_index
                        ):
                            self.element_index_map[parameter] = reversed_container_dict[
                                (opening_parenthesis_index, closing_parenthesis_index)
                            ]
                        else:
                            self.element_index_map[parameter] = "default"
                        try:
                            if len(element_map[parameter]) > 2:
                                element_map[parameter] = element_map[parameter].pop(
                                    element_map[parameter].index(element_index)
                                )
                        except:
                            element_map.pop(parameter)
            self.global_element_map = element_map
            self.container_dict = container_dict

        def calculateMultipliers(self) -> None:
            closing_pair_index: int = 0
            multiplier: int = 1
            for index, pair_index in enumerate(list(self.container_dict.values())):
                closing_pair_index = pair_index[1]
                i = 1
                while True:
                    try:
                        if (
                            self.chemical_formula[closing_pair_index + i]
                            in self.number_list
                        ):
                            i += 1
                            continue
                    except:
                        multiplier = self.chemical_formula[
                            closing_pair_index + 1 : closing_pair_index + i
                        ]
                        if multiplier == "":
                            multiplier = 1
                        break
                self.container_dict[index] = multiplier
            for element in list(self.element_index_map.keys()):
                if self.element_index_map[element] == "default":
                    self.element_index_map[element] = 1
                else:
                    self.element_index_map[element] = self.container_dict[
                        self.element_index_map[element]
                    ]

        def countElements(self) -> dict:
            element_counts: dict = {}
            length: int = 0
            for element in list(self.global_element_map.keys()):
                length = self.global_element_map[element][0]
                for _ in self.global_element_map[element][1:]:
                    count = ""
                    i = 1
                    while self.chemical_formula[_ + length + i - 1] in self.number_list:
                        count += self.chemical_formula[_ + length + i - 1]
                        i += 1
                    if count == "":
                        count = "1"
                    if element in element_counts:
                        element_counts[element] += int(count)
                    else:
                        element_counts[element] = int(count)
            return element_counts

        def calculateFinalCounts(self) -> dict:
            count_map: dict = self.countElements()
            final_count_map: dict = {}
            for element in self.present_elements:
                final_count_map[element] = int(count_map[element]) * int(
                    self.element_index_map[element]
                )
            return final_count_map

        def run(self):
            self.mapElements()
            self.calculateMultipliers()
            return self.calculateFinalCounts()

    # --------------

    class EquationParser:
        def __init__(self, chemical_equation: str) -> None:
            self.chemical_equation: str = chemical_equation
            self.equation_splitter: str = "="
            self.species_splitter: str = "+"

            self.reactants_list: list[str] = []
            self.products_list: list[str] = []

            self.parsed_reactants: dict = {}
            self.parsed_products: dict = {}

        def splitIntoSpecies(self) -> None:
            # Split the equation into reactants and products
            splitted_equation: list[str] = self.chemical_equation.split(
                self.equation_splitter
            )

            # Split the reactants and products into individual species
            # and enclose each species in parentheses if it is not already
            self.reactants_list = [
                (
                    "(" + species.strip() + ")"
                    if not species.strip().startswith("(")
                    else species.strip()
                )
                for species in splitted_equation[0].split(self.species_splitter)
            ]
            self.products_list = [
                (
                    "(" + species.strip() + ")"
                    if not species.strip().startswith("(")
                    else species.strip()
                )
                for species in splitted_equation[1].split(self.species_splitter)
            ]

        def countElementsInChemicalSpecie(self) -> None:
            for reactant in self.reactants_list:
                self.parsed_reactants[reactant] = (
                    EquationUtil().ElementCounter(chemical_formula=reactant).run()
                )

            for product in self.products_list:
                self.parsed_products[product] = (
                    EquationUtil().ElementCounter(chemical_formula=product).run()
                )

        def parse(self):
            self.splitIntoSpecies()
            self.countElementsInChemicalSpecie()
            return [self.parsed_reactants, self.parsed_products]

    # --------------

    class LinearEquationSystemGenerator:
        def __init__(self, chemical_equation: str) -> None:
            self.chemical_equation: str = chemical_equation

            self.parameter_symbols: str = assets.parameter_symbols
            # Junior code, BUG, fix it
            equation_parser_object: object = EquationUtil().EquationParser(
                chemical_equation=chemical_equation
            )
            equation_parser_object.parse()
            #
            self.reactants_list: list[str] = equation_parser_object.reactants_list
            self.products_list: list[str] = equation_parser_object.products_list

            self.present_elements_in_reaction: list[str] = []

            self.parsed_reactants: dict[str, dict[str, str]] = (
                equation_parser_object.parsed_reactants
            )
            self.parsed_products: dict[str, dict[str, str]] = (
                equation_parser_object.parsed_products
            )
            self.reactants_assigned_parameter_dict: dict[str, str] = {}
            self.products_assigned_parameter_dict: dict[str, str] = {}
            self.demand_for_variables_to_solve_count: int = 0
            self.parametric_equations_list: list[str] = []

            # atexit.register(self.saveParameterAssignedChemicalFormulas)

        def presentElementsInFormula(self, chemical_formula: str) -> list:
            return list(
                EquationUtil().ElementMapper(chemical_formula=chemical_formula).search()
            )

        def presentElementsInReaction(self) -> list:
            element_list: list[str] = []
            temp_list: list = []
            reactants_list: list[str] = self.reactants_list
            products_list: list[str] = self.products_list

            for reactant in reactants_list:
                temp_list.append(
                    self.presentElementsInFormula(chemical_formula=reactant)
                )

            for product in products_list:
                temp_list.append(
                    self.presentElementsInFormula(chemical_formula=product)
                )

            for sublist in temp_list:
                element_list.extend(sublist)

            element_list = list(set(element_list))
            self.present_elements_in_reaction = element_list
            self.demand_for_variables_to_solve_count = len(self.reactants_list) + len(
                self.products_list
            )  # Junior code, BUG, fix the formula

        def assignParameter(self) -> None:
            self.presentElementsInReaction()
            removing_index: int = 0

            for i, reactant in enumerate(self.reactants_list):
                self.reactants_assigned_parameter_dict[reactant] = (
                    self.parameter_symbols[i]
                )
                removing_index = i

            self.parameter_symbols = self.parameter_symbols[removing_index + 1 :]

            for i, product in enumerate(self.products_list):
                self.products_assigned_parameter_dict[product] = self.parameter_symbols[
                    i
                ]
                removing_index = i

            self.parameter_symbols = self.parameter_symbols[removing_index + 1 :]

        def generateEquationSystem(self) -> list:
            self.assignParameter()
            equations_list: list[str] = []
            equation: str = ""
            left_hand: str = ""
            right_hand: str = ""

            for element in self.present_elements_in_reaction:
                for reactant in self.reactants_list:
                    if element in self.parsed_reactants[reactant]:
                        left_hand += f"{self.parsed_reactants[reactant][element]}*{self.reactants_assigned_parameter_dict[reactant]}+"

                for product in self.products_list:
                    if element in self.parsed_products[product]:
                        right_hand += f"{self.parsed_products[product][element]}*{self.products_assigned_parameter_dict[product]}-"

                left_hand = left_hand[:-1]
                right_hand = right_hand[:-1]

                equation = f"{left_hand}-{right_hand}"
                equations_list.append(equation)
                left_hand = ""
                right_hand = ""

            return equations_list

            # def saveParameterAssignedChemicalFormulas(self) -> None:
            """
            Note : The name of this function might be confusing but
            the propose of this function is just storing
            the parameter assigned chemical formulas in the
            self.parameterAssignedChemicalFormulas
            this is also crucial because in earlier versions
            this function saves this content in a single .pkl file
            which wasn't worked well."""

            # EquationUtil().parameter_assigned_chemical_formulas_dict = {
            #     **self.reactants_assigned_parameter_dict,
            #     **self.products_assigned_parameter_dict,
            # }
            # print("FU", self.reactants_assigned_parameter_dict)
            # print("FM", self.products_assigned_parameter_dict)

    # --------------

    class LinearEquationSystemSolverFileMaker:
        def __init__(self, chemical_equation: str) -> None:
            self.chemical_equation = chemical_equation
            self.current_directory = os.path.dirname(__file__)
            equation_generator_object = EquationUtil().LinearEquationSystemGenerator(
                chemical_equation=self.chemical_equation
            )
            # equation_generator_object.saveParameterAssignedChemicalFormulas()

            self.system_of_linear_equations = (
                equation_generator_object.generateEquationSystem()
            )
            self.num_of_variables = (
                equation_generator_object.demand_for_variables_to_solve_count
            )
            self.symbols_list = assets.parameter_symbols
            self.variables_str = ""

            for i, symbol in enumerate(self.symbols_list):
                self.variables_str += symbol
                if self.num_of_variables == i:
                    break
                else:
                    self.variables_str += ","

            # print(
            #     "assigned", equation_generator_object.reactants_assigned_parameter_dict
            # )
            EquationUtil().set_parameter_assigned_chemical_formulas_dict(
                value={
                    **equation_generator_object.reactants_assigned_parameter_dict,
                    **equation_generator_object.products_assigned_parameter_dict,
                }
            )

        def generateEquationAndSaveSolverFile(self):
            """
            Generates the system of linear equations from the chemical equation.
            """
            self.variables_str = self.variables_str[0:-2]
            file_content = rf"""# [DO NOT MODIFY] Automatically generated by EquationUtil().LinearEquationSystemSolverFileMaker
from sympy import symbols
from sympy.solvers.solveset import linsolve
import pickle
import os


current_directory = os.path.dirname(__file__)
{self.variables_str} = symbols("{self.variables_str}")
solution = linsolve({self.system_of_linear_equations},({self.variables_str}))
with open(r"{self.current_directory}\solution.automatic.pkl","wb") as solution_file:
    pickle.dump(list(solution)[0],solution_file)
            """

            with open(
                rf"{self.current_directory}\linear_equations_system_solver.automatic.py",
                "w",
            ) as solver_file:
                solver_file.write(file_content)

            EquationUtil().set_last_parameter(value=self.variables_str[-1])

        def executeSolverFile(self):
            """
            Solves the system of linear equations and writes the solution to a file.
            """

            with open(
                rf"{self.current_directory}\linear_equations_system_solver.automatic.py"
            ) as file:
                exec(file.read())

    # --------------

    class ChemicalReactionRewriter:
        def __init__(self) -> None:
            self.parent_folder_directory = os.path.dirname(__file__)
            self.equation_solution: tuple = ()
            self.chemical_formulas_dict = {}
            self.reactants_list: list[str] = []
            self.products_list: list[str] = []
            self.last_parameter: str = ""

            self.assigned_reactants_list: list[str] = []
            self.assigned_products_list: list[str] = []

        def loadEquationSolution(self):
            with open(
                rf"{self.parent_folder_directory}\solution.automatic.pkl", "rb"
            ) as solution_file:
                self.equation_solution = pickle.load(solution_file)

        def substituteSymbolsInSolution(self):
            x = symbols(last_parameter)
            self.equation_solution = [
                expr.subs(x, 1) for expr in self.equation_solution
            ]

        def loadChemicalFormulasDictionary(self, chemical_equation: str):
            # self.chemical_formulas_dict: dict = (
            #     EquationUtil().parameter_assigned_chemical_formulas_dict
            # )
            # epo = EquationUtil.EquationParser(chemical_equation="AlBr3 = Al + Br2")
            epo = EquationUtil.EquationParser(chemical_equation=chemical_equation)
            epo.parse()

            # self.chemical_formulas_dict = [*epo.reactants_list, *epo.products_list]

            for reac in epo.reactants_list:
                reac = reac.replace("(", "")
                reac = reac.replace(")", "")
                self.chemical_formulas_dict[reac] = 0
                self.reactants_list.append(reac)

            for prod in epo.products_list:
                prod = prod.replace("(", "")
                prod = prod.replace(")", "")
                self.chemical_formulas_dict[prod] = 0
                self.products_list.append(prod)

            # print(EquationUtil().parameter_assigned_chemical_formulas_dict)
            self.last_parameter: str = last_parameter
            # print(self.chemical_formulas_dict, self.reactants_list, self.products_list)

        def assignCoefficientsToChemicalFormulas(self) -> None:

            for index, chemical_formula in enumerate(
                list(self.chemical_formulas_dict.keys())
            ):
                self.chemical_formulas_dict[chemical_formula] = self.equation_solution[
                    index
                ]

            for reactant in self.reactants_list:
                if self.chemical_formulas_dict[reactant] == 1:
                    self.assigned_reactants_list.append(reactant)
                else:
                    self.assigned_reactants_list.append(
                        f"{self.chemical_formulas_dict[reactant]} {reactant}"
                    )

            for product in self.products_list:
                if self.chemical_formulas_dict[product] == 1:
                    self.assigned_products_list.append(product)
                else:
                    self.assigned_products_list.append(
                        f"{self.chemical_formulas_dict[product]} {product}"
                    )

        def executeRewriter(self, chemical_equation: str):
            self.loadEquationSolution()
            self.substituteSymbolsInSolution()
            self.loadChemicalFormulasDictionary(chemical_equation=chemical_equation)
            self.assignCoefficientsToChemicalFormulas()

            reactants_string: str = ""
            products_string: str = ""

            for reactant in self.assigned_reactants_list:
                reactants_string += f"{reactant} + "

            for product in self.assigned_products_list:
                products_string += f"{product} + "

            reactants_string = reactants_string[:-2]
            products_string = products_string[:-2]

            return f"{reactants_string} = {products_string}"

    # --------------

    def execute(self, input_chemical_equation: str) -> None:

        linear_equations_system_object: (
            object
        ) = EquationUtil().LinearEquationSystemSolverFileMaker(
            chemical_equation=input_chemical_equation
        )
        linear_equations_system_object.generateEquationAndSaveSolverFile()
        linear_equations_system_object.executeSolverFile()
        # print(EquationUtil().parameter_assigned_chemical_formulas_dict)
        # print(EquationUtil().last_parameter)
        # print(parameter_assigned_chemical_formulas_dict)
        # print(last_parameter)

        return (
            EquationUtil()
            .ChemicalReactionRewriter()
            .executeRewriter(chemical_equation=input_chemical_equation)
        )


# example usage :

# eq = FeCr2O4 + K2CO3 + O2 = Fe2O3 + K2CrO4 + CO2"

# print(
#     "The balanced equation for > {0} < is \n >> {1} <<".format(
#         eq, EquationUtil().execute(input_chemical_equation=eq)
#     )
# )
# output : 1/2 FeCr2O4 + K2CO3 + 7/8 O2  = 1/4 Fe2O3 + K2CrO4 + CO2
